<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>潇潇雨歇的博客</title>
  
  <subtitle>诗酒趁年华</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yangl.me/"/>
  <updated>2017-09-21T08:39:10.472Z</updated>
  <id>https://yangl.me/</id>
  
  <author>
    <name>yangl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux模拟网络异常的工具 - TC</title>
    <link href="https://yangl.me/2017/06/30/tc/"/>
    <id>https://yangl.me/2017/06/30/tc/</id>
    <published>2017-06-29T16:00:00.000Z</published>
    <updated>2017-09-21T08:39:10.472Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/in-post/tc.png" alt="tc"></p><p>Linux Traffic Control (tc)的扩展 Network Emulation (netem)可以很方便的模拟网络不好的情况，一般新的linux内核中(&gt;= 2.6)已经内置了这个工具，可以方便的进行测试。<br>本文罗列了了 tc的常用的模拟命令， 以备将来使用的时候查询。</p><p>主要参考了Linux基金会的官方介绍: <a href="https://wiki.linuxfoundation.org/networking/netem" target="_blank">netem</a></p><h3 id="1-选择要监控网卡"><a href="#1-选择要监控网卡" class="headerlink" title="1.选择要监控网卡"></a>1.选择要监控网卡</h3><p>首先要查看你的网卡信息，如: <code>eth0</code>, 然后加入监控列表<code>sudo tc qdisc add dev eth0 root netem</code></p><p>如果不想再监控，可以移除这个网卡<code>sudo tc qdisc del dev eth0 root netem</code></p><p>如果想查看监控列表， 可以使用<code>tc -s qdisc</code></p><p><code>qdisc</code>是<code>queueing discipline</code>的缩写</p><h3 id="2-模拟网络延迟"><a href="#2-模拟网络延迟" class="headerlink" title="2.模拟网络延迟"></a>2.模拟网络延迟</h3><p>2.1 <em>固定延迟</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc add dev eth0 root netem delay 100ms</div></pre></td></tr></table></figure><p>每个包都固定延迟<code>100毫秒</code>， 设置好后你可以使用ping命令测试。</p><p>2.2 <em>固定延迟+小随机值</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay 100ms 10ms</div></pre></td></tr></table></figure><p>延迟时间变成了 100ms ± 10ms</p><p>2.3 <em>固定延迟+小随机值+相关系数</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay 100ms 10ms 25%</div></pre></td></tr></table></figure><p>2.4 <em>遵循正态分布的延迟</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay 100ms 20ms distribution normal</div></pre></td></tr></table></figure><p>分布为normal、 pareto、 paretonormal等。</p><h3 id="3-模拟丢包"><a href="#3-模拟丢包" class="headerlink" title="3.模拟丢包"></a>3.模拟丢包</h3><p>随机丢弃一些包， 丢弃比率可以设置。丢失比最小为 <code>232 = 0.0000000232%</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem loss 0.1%</div></pre></td></tr></table></figure><p>上述命令会随机丢弃千分之一的包。</p><p>你还可以增加一个相关参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem loss 0.3% 25%</div></pre></td></tr></table></figure><p>丢弃率为千分之三， 后一个的丢弃的可能性和前一个的可能性的25%相关</p><h3 id="4-模拟包重复"><a href="#4-模拟包重复" class="headerlink" title="4.模拟包重复"></a>4.模拟包重复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem duplicate 1%</div></pre></td></tr></table></figure><p>类似丢包的命令，上面命令产生百分之一的重复包。</p><h3 id="5-模拟错误包"><a href="#5-模拟错误包" class="headerlink" title="5.模拟错误包"></a>5.模拟错误包</h3><p>模拟随机噪音(错误包)， 这个功能在 2.6.16以及以后的版本中才加入。它会在包中随机位置更改一个bit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem corrupt 0.1%</div></pre></td></tr></table></figure><h3 id="6-模拟包乱序"><a href="#6-模拟包乱序" class="headerlink" title="6.模拟包乱序"></a>6.模拟包乱序</h3><p>1） 方式一<br>使用 gap。 第5th包（5、10、15、20）立即发送，其它的包会延迟10毫秒。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem gap 5 delay 10ms</div></pre></td></tr></table></figure><p>2） 方式二<br>方式一乱序方式是固定的，可以预测的。方式二引入随机性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay 10ms reorder 25% 50%</div></pre></td></tr></table></figure><p>25%的包会立即发送， 其它的包会延迟10毫秒。相关系数为50%。</p><p>新版的netem的包延迟设置也可能导致包乱序，如果包延迟的有一定的随机性的话：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tc qdisc change dev eth0 root netem delay 100ms 75ms</div></pre></td></tr></table></figure><p>因为延迟时间在100ms ± 75ms返回内， 就有可能第二包的延迟比第一个包的延迟小，先发出去。</p><h3 id="7-控制包速-带宽"><a href="#7-控制包速-带宽" class="headerlink" title="7.控制包速(带宽)"></a>7.控制包速(带宽)</h3><p>没有直接命令，需要两条命令配合使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tc qdisc add dev eth0 root handle 1:0 netem delay 100ms</div><div class="line">tc qdisc add dev eth0 parent 1:1 handle 10: tbf rate 256kbit buffer 1600 <span class="built_in">limit</span> 3000</div><div class="line">tc -s qdisc ls dev eth0</div><div class="line"></div><div class="line">qdisc netem 1: <span class="built_in">limit</span> 1000 delay 100.0ms</div><div class="line">Sent 0 bytes 0 pkts (dropped 0, overlimits 0 )</div><div class="line">qdisc tbf 10: rate 256Kbit burst 1599b lat 26.6ms</div><div class="line">Sent 0 bytes 0 pkts (dropped 0, overlimits 0 )</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/in-post/tc.png&quot; alt=&quot;tc&quot;&gt;&lt;/p&gt;
&lt;p&gt;Linux Traffic Control (tc)的扩展 Network Emulation (netem)可以很方便的模拟网络不好的情况，一般新的linux内核中(&amp;g
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="linux" scheme="https://yangl.me/tags/linux/"/>
    
      <category term="tc" scheme="https://yangl.me/tags/tc/"/>
    
  </entry>
  
  <entry>
    <title>使用Kubeadm部署Kubernetes 1.6.1</title>
    <link href="https://yangl.me/2017/04/24/kubernetes-1.6.1-deploy/"/>
    <id>https://yangl.me/2017/04/24/kubernetes-1.6.1-deploy/</id>
    <published>2017-04-23T16:00:00.000Z</published>
    <updated>2017-09-21T08:39:01.541Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/in-post/kub_video_banner.jpg" alt="kubernetes"></p><h3 id="部署方案与环境准备"><a href="#部署方案与环境准备" class="headerlink" title="部署方案与环境准备"></a>部署方案与环境准备</h3><p>k8s集群    kubernetes 1.6.1 + Docker 1.12</p><p>容器网络   calico</p><p>监控       prometheus</p><p>服务暴露   traefik + ingress</p><p>日志收集   graylog</p><p>1.准备机器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">192.168.61.41 node1</div><div class="line">192.168.61.42 node2</div><div class="line">192.168.61.43 node3</div></pre></td></tr></table></figure></p><p>系统版本要求Centos 7.2或以上, 内核版本 3.18以上(docker的overlay stroage 要求)</p><p>2.准备docker的yum源,创建/etc/yum.repos.d/docker.repo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[docker-repo]</div><div class="line">name=Docker Repository</div><div class="line">baseurl=http://mirrors.aliyun.com/docker-engine/yum/repo/main/centos/$releasever/</div><div class="line">enabled=1</div><div class="line">gpgcheck=0</div></pre></td></tr></table></figure></p><p>3.Kuberntes的yum源,创建/etc/yum.repos.d/k8s.repo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[k8s-repo]</div><div class="line">name=k8s Repository</div><div class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</div><div class="line">enabled=1</div><div class="line">gpgcheck=0</div></pre></td></tr></table></figure></p><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>查看docker版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum list docker-engine --showduplicates</div></pre></td></tr></table></figure></p><p>Kubernetes 1.6还没有针对docker 1.13和最新的docker 17.03上做测试和验证，所以这里安装Kubernetes官方推荐的Docker 1.12版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y docker-engine-1.12.6-1.el7.centos.x86_64</div></pre></td></tr></table></figure></p><h3 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h3><p>根据官方文档<a href="https://kubernetes.io/docs/getting-started-guides/kubeadm/#limitations" target="_blank">Installing Kubernetes on Linux with kubeadm</a>中的Limitations小节中的内容，对各节点系统做如下设置:</p><p>创建/etc/sysctl.d/k8s.conf文件,添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">net.bridge.bridge-nf-call-ip6tables = 1</div><div class="line">net.bridge.bridge-nf-call-iptables = 1</div></pre></td></tr></table></figure></p><p>执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效</p><h3 id="安装kubeadm和kubelet"><a href="#安装kubeadm和kubelet" class="headerlink" title="安装kubeadm和kubelet"></a>安装kubeadm和kubelet</h3><p>查看kubeadm, kubelet, kubectl, kubernets-cni的最新版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum list kubeadm --showduplicates</div><div class="line">kubeadm.x86_64   1.6.1-0   @k8s-repo</div><div class="line">kubeadm.x86_64   1.6.0-0   k8s-repo</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum list kubelet --showduplicates</div><div class="line">kubelet.x86_64   1.6.1-0   @k8s-repo</div><div class="line">kubelet.x86_64   1.6.0-0   k8s-repo</div></pre></td></tr></table></figure><p>kubeadm和kubelet已经是1.6.1版本,直接安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y kubelet kubeadm kubectl kubernetes-cni</div></pre></td></tr></table></figure></p><p>启用kubelet服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl enable kubelet.service</div></pre></td></tr></table></figure></p><h3 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h3><p>准备MasterConfiguration文件<br>cat k8s_master_config.yaml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apiVersion: kubeadm.k8s.io/v1alpha1</div><div class="line">kind: MasterConfiguration</div><div class="line">api:</div><div class="line">  advertiseAddress: 192.168.61.41</div><div class="line">networking:</div><div class="line">  dnsDomain: cluster.local</div><div class="line">kubernetesVersion: v1.6.1</div></pre></td></tr></table></figure></p><h3 id="准备镜像"><a href="#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h3><p>kubeadm部署时默认会去gcr.io拉取镜像, 这个域名国内被墙了, 所以要曲线救国</p><ol><li>先购买一台海外的vps, 部署squid, 参考<a href="http://dockone.io/article/1380" target="_blank">使用Squid3搭建Docker镜像下载代理</a></li><li>给docker增加HTTP_PROXY设置<br>编辑/usr/lib/systemd/system/docker.service<br>增加如下内容:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Environment=&quot;HTTP_PROXY=YOUR_VPS_IP:3128&quot;</div><div class="line">Environment=&quot;HTTPS_PROXY=YOUR_VPS_IP:3128&quot;</div><div class="line">Environment=&quot;NO_PROXY=YOUR_REGISTRY_DOMAIN&quot;</div></pre></td></tr></table></figure></li></ol><p>ip地址改为自己的vps的地址, 保存重启docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl daemon-reload &amp; systemctl restart docker</div></pre></td></tr></table></figure></p><ol><li>拉取kubernetes部署所需镜像,参考<a href="https://kubernetes.io/docs/getting-started-guides/kubeadm/#Master Images" target="_blank">Master Images</a></li><li>拉取镜像完成后tag为自己的私服的域名然后push</li><li>编辑 /etc/profile,加入docker私服地址到环境变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export KUBE_REPO_PREFIX=registry.youregistry.com/google_containers</div></pre></td></tr></table></figure></li></ol><p>这样配置的话,kubeadm在init时会向registry.youregistry.com 拉取镜像</p><h3 id="部署集群"><a href="#部署集群" class="headerlink" title="部署集群"></a>部署集群</h3><p>使用kubeadm初始化集群，选择node1作为Master Node，在node1上执行下面的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubeadm init --config k8s_master_config.yaml</div></pre></td></tr></table></figure></p><p>k8s_master_config.yaml为kubeadm的config文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apiVersion: kubeadm.k8s.io/v1alpha1</div><div class="line">kind: MasterConfiguration</div><div class="line">api:</div><div class="line">  advertiseAddress: 192.168.61.41</div><div class="line">networking:</div><div class="line">  dnsDomain: cluster.local</div><div class="line">kubernetesVersion: v1.6.1</div></pre></td></tr></table></figure></p><p>kubeadm init执行成功后输出下面的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">kubeadm init --config k8s_master_config.yaml</div><div class="line">[kubeadm] WARNING: kubeadm is in beta, please do not use it for production clusters.</div><div class="line">[init] Using Kubernetes version: v1.6.1</div><div class="line">[init] Using Authorization mode: RBAC</div><div class="line">[preflight] Running pre-flight checks</div><div class="line">[preflight] Starting the kubelet service</div><div class="line">[certificates] Generated CA certificate and key.</div><div class="line">[certificates] Generated API server certificate and key.</div><div class="line">[certificates] API Server serving cert is signed for DNS names [node0 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.61.41]</div><div class="line">[certificates] Generated API server kubelet client certificate and key.</div><div class="line">[certificates] Generated service account token signing key and public key.</div><div class="line">[certificates] Generated front-proxy CA certificate and key.</div><div class="line">[certificates] Generated front-proxy client certificate and key.</div><div class="line">[certificates] Valid certificates and keys now exist in &quot;/etc/kubernetes/pki&quot;</div><div class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/admin.conf&quot;</div><div class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/kubelet.conf&quot;</div><div class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/controller-manager.conf&quot;</div><div class="line">[kubeconfig] Wrote KubeConfig file to disk: &quot;/etc/kubernetes/scheduler.conf&quot;</div><div class="line">[apiclient] Created API client, waiting for the control plane to become ready</div><div class="line">[apiclient] All control plane components are healthy after 14.583864 seconds</div><div class="line">[apiclient] Waiting for at least one node to register</div><div class="line">[apiclient] First node has registered after 6.008990 seconds</div><div class="line">[token] Using token: e7986d.e440de5882342711</div><div class="line">[apiconfig] Created RBAC rules</div><div class="line">[addons] Created essential addon: kube-proxy</div><div class="line">[addons] Created essential addon: kube-dns</div><div class="line">Your Kubernetes master has initialized successfully!</div><div class="line">To start using your cluster, you need to run (as a regular user):</div><div class="line">  sudo cp /etc/kubernetes/admin.conf $HOME/</div><div class="line">  sudo chown $(id -u):$(id -g) $HOME/admin.conf</div><div class="line">  export KUBECONFIG=$HOME/admin.conf</div><div class="line">You should now deploy a pod network to the cluster.</div><div class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</div><div class="line">  http://kubernetes.io/docs/admin/addons/</div><div class="line">You can now join any number of machines by running the following on each node</div><div class="line">as root:</div><div class="line">  kubeadm join --token e7986d.e440de5882342711 192.168.61.41:6443</div></pre></td></tr></table></figure></p><p>出现token说明Master初始化完成，使用kubeadm初始化的Kubernetes集群在Master节点上的核心组件：kube-apiserver,kube-scheduler, kube-controller-manager是以静态Pod的形式运行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ls -l /etc/kubernetes/manifests/</div><div class="line">etcd.yaml</div><div class="line">kube-apiserver.yaml</div><div class="line">kube-controller-manager.yaml</div><div class="line">kube-scheduler.yaml</div></pre></td></tr></table></figure></p><p>如果想修改kubernetes组件的参数, 可以修改对应组件的yaml配置文件, 然后重启kubelet服务使之生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart kubelet</div></pre></td></tr></table></figure></p><h3 id="部署Pod-Network"><a href="#部署Pod-Network" class="headerlink" title="部署Pod Network"></a>部署Pod Network</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl create -f http://yangl.me/file/calico.yaml</div></pre></td></tr></table></figure><p>查看pod状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl get pod --all-namespaces -o wide</div></pre></td></tr></table></figure></p><p>使master node参与工作负载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl taint nodes --all  node-role.kubernetes.io/master-</div></pre></td></tr></table></figure></p><p>测试DNS是否正常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl run curl --image=radial/busyboxplus:curl -i --tty</div></pre></td></tr></table></figure></p><p>进入容器之后测试下nslookup kubernetes.default<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ root@curl-2421989462-vldmp:/ ]$ nslookup kubernetes.default</div><div class="line">Server:    10.96.0.10</div><div class="line">Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local</div><div class="line">Name:      kubernetes.default</div><div class="line">Address 1: 10.96.0.1 kubernetes.default.svc.cluster.local</div></pre></td></tr></table></figure></p><p>测试没问题后删除pod<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl delete deploy curl</div></pre></td></tr></table></figure></p><h3 id="节点加入到集群"><a href="#节点加入到集群" class="headerlink" title="节点加入到集群"></a>节点加入到集群</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubeadm join --token c9b51c.416daf3a9bf8ebcd 192.168.61.41:6443</div></pre></td></tr></table></figure><p>如果token忘记了,可以在master上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubeadm token list</div></pre></td></tr></table></figure></p><h3 id="部署traefik以暴露服务"><a href="#部署traefik以暴露服务" class="headerlink" title="部署traefik以暴露服务"></a>部署traefik以暴露服务</h3><p>traefik(<a href="https://traefik.io/" target="_blank">https://traefik.io</a>)是一款开源的反向代理与负载均衡工具。它最大的优点是能够与常见的微服务系统直接整合，可以实现自动化动态配置。<br>关于traefik的详细信息请参考<a href="https://ipfans.github.io/2016/08/introduce-traefik-load-balance/" target="_blank">traefik简介</a></p><p>下面来部署traefik<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl create -f http://yangl.me/file/traefik-with-ui-rbac.yaml</div></pre></td></tr></table></figure></p><p>配置文件中traefik-ui暴露的域名为traefik-ui.local, 所以只需配置一个A记录指向此域名, 也可以改成自己想要的域名.</p><h3 id="安装Dashboard"><a href="#安装Dashboard" class="headerlink" title="安装Dashboard"></a>安装Dashboard</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl create -f http://yangl.me/file/kubernetes-dashboard.yaml</div></pre></td></tr></table></figure><p>配置文件中dashboard暴露的域名为dashboard.local, 同样需要设置一个A记录或者host</p><h3 id="prometheus监控系统部署"><a href="#prometheus监控系统部署" class="headerlink" title="prometheus监控系统部署"></a>prometheus监控系统部署</h3><p>prometheus的部署比较简单, 可参考<a href="https://github.com/kayrus/prometheus-kubernetes" target="_blank">prometheus-kubernetes</a></p><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/in-post/kub_video_banner.jpg&quot; alt=&quot;kubernetes&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;部署方案与环境准备&quot;&gt;&lt;a href=&quot;#部署方案与环境准备&quot; class=&quot;headerlink&quot; title=&quot;部
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="kubernetes" scheme="https://yangl.me/tags/kubernetes/"/>
    
      <category term="docker" scheme="https://yangl.me/tags/docker/"/>
    
      <category term="caas" scheme="https://yangl.me/tags/caas/"/>
    
      <category term="traefik" scheme="https://yangl.me/tags/traefik/"/>
    
      <category term="prometheus" scheme="https://yangl.me/tags/prometheus/"/>
    
      <category term="calico" scheme="https://yangl.me/tags/calico/"/>
    
      <category term="graylog" scheme="https://yangl.me/tags/graylog/"/>
    
  </entry>
  
  <entry>
    <title>禁PING也能PING的工具 - TCPING</title>
    <link href="https://yangl.me/2016/11/02/tcping/"/>
    <id>https://yangl.me/2016/11/02/tcping/</id>
    <published>2016-11-01T16:00:00.000Z</published>
    <updated>2017-09-21T08:37:19.884Z</updated>
    
    <content type="html"><![CDATA[<p>一般查看网络延迟我们都会用到ping命令，简单明了。但是机房服务器禁止ping了怎么办，这时候就可以用到tcping了。tcping 是类似ping的工具(禁止ping也能ping) ，因为这个软件是针对TCP监控的，也可以看到ping 值，即使服务器禁PING了（ping是通过icmp协议来工作的），也可以通过它来监控服务器的情况。除了ping ，它还有一个功能，监听端口的状态。使用方法很简单，就是把它放在C盘windows目录下的system32文件夹下就可以像平时使用ping一样使用它了。</p><p><img src="/images/in-post/tcping.jpg" height="100%" width="100%"></p><p>格式就是如图所示，tcping+IP或网址，默认是80端口，也可以自定义端口，tcping+IP或网址+端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tcping www.baidu.com</div><div class="line">tcping -t www.baidu.com 【参数-t 是让命令一直运行ping】</div><div class="line">tcping -d -t www.baidu.com 【参数 -d 是显示时间】</div><div class="line">tcping -d -t www.baidu.com 21 【21 是您所需要监听的端口,可以自己定义】</div></pre></td></tr></table></figure><p>下载地址:<br><a href="http://www.elifulkerson.com/projects/downloads/tcping-0.34/tcping.exe" target="_blank">32位tcping下载</a><br><a href="http://www.elifulkerson.com/projects/downloads/tcping-0.34/tcping64.exe" target="_blank">64位tcping下载</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般查看网络延迟我们都会用到ping命令，简单明了。但是机房服务器禁止ping了怎么办，这时候就可以用到tcping了。tcping 是类似ping的工具(禁止ping也能ping) ，因为这个软件是针对TCP监控的，也可以看到ping 值，即使服务器禁PING了（ping
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="ping" scheme="https://yangl.me/tags/ping/"/>
    
  </entry>
  
  <entry>
    <title>Git简易入门</title>
    <link href="https://yangl.me/2016/10/08/git-cmd/"/>
    <id>https://yangl.me/2016/10/08/git-cmd/</id>
    <published>2016-10-07T16:00:00.000Z</published>
    <updated>2017-09-22T05:28:21.141Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文旨在于分分钟教你使用命令行进行 Git 配置与操作，废话不多说，直接上干货。</p></blockquote><h2 id="git-安装"><a href="#git-安装" class="headerlink" title="git 安装"></a>git 安装</h2><h3 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h3><h4 id="操作系统为：Ubuntu14-04"><a href="#操作系统为：Ubuntu14-04" class="headerlink" title="操作系统为：Ubuntu14.04"></a>操作系统为：Ubuntu14.04</h4><p><a href="https://github.com/git/git/releases" target="_blank">点击此处</a>下载 tar.gz 格式文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ tar -zxvf git-2.7.1.tar.gz</div><div class="line">$ cd git-2.7.1/</div><div class="line">$ make prefix=/usr/local all</div><div class="line">$ sudo make prefix=/usr/local install</div></pre></td></tr></table></figure><h3 id="Windows平台安装"><a href="#Windows平台安装" class="headerlink" title="Windows平台安装"></a>Windows平台安装</h3><p>windows 下安装 Git 不要太简单，<a href="https://git-scm.com/download/" target="_blank">点击此处</a> 选择 exe 文件进行下载，然后一直下一步就好，唯一要注意的就是安装的时候选择免费版。</p><h2 id="git配置"><a href="#git配置" class="headerlink" title="git配置"></a>git配置</h2><p>下面是 git 的一些配置和操作，在 Linux 系统的终端和 windows 下的 Git Bash 中都可以运行。</p><ul><li>用户名和邮箱</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;xiaoming&quot; # 用户名设置成了 xiaoming</div><div class="line">$ git config --global user.email &quot;xiaoming@126.com&quot;</div></pre></td></tr></table></figure><ul><li>generate ssh key</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;xiaoming@126.com&quot; # Creates a new ssh key using the provided email</div></pre></td></tr></table></figure><ul><li>alias 设置，操作变得更加简单</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git config --global alias.br branch # git br 即 git branch</div><div class="line">$ git config --global alias.ci commit</div><div class="line">$ git config --global alias.co checkout</div><div class="line">$ git config --global alias.st status</div></pre></td></tr></table></figure><ul><li>换行符设置成 false</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global core.autocrlf false</div></pre></td></tr></table></figure><ul><li>为了保险起见，设置成单分支提交</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global push.default simple</div></pre></td></tr></table></figure><ul><li>查看配置信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --list</div></pre></td></tr></table></figure><h2 id="git-操作"><a href="#git-操作" class="headerlink" title="git 操作"></a>git 操作</h2><p>操作前请保证有足够的权限进行相关操作。</p><ul><li>clone 远程仓库，语法：git clone 远程仓库地址</li></ul><p>比如：将 fanxing 项目 clone 到本地的 /d/fanxing_git/ 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd /d/fanxing_git/</div><div class="line">$ git clone 项目地址</div></pre></td></tr></table></figure><ul><li>从远程仓库检出分支，语法：git checkout -b 本地分支名 远程分支名</li></ul><p>比如：将远程的 abc 分支检出到本地并切换到相应分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b abc origin/abc</div></pre></td></tr></table></figure><ul><li>删除本地分支，语法：git branch -d 本地分支名</li></ul><p>比如：删除本地的 abc 分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -d abc</div></pre></td></tr></table></figure><p>如果用上面那一句删除不成功的话，可以尝试使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -D abc</div></pre></td></tr></table></figure><ul><li>重命名本地分支，语法：git branch -m 原有分支名 新分支名</li></ul><p>比如：将本地分支 abc 重命名为 xyz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -m abc xyz</div></pre></td></tr></table></figure><ul><li>push 分支，方法是切换到相应本地分支，再执行 git push origin</li></ul><p>比如：将本地分支 abc 推送到远程仓库的 origin/abc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout abc # 切换到 abc 分支</div><div class="line">$ git push origin</div></pre></td></tr></table></figure><ul><li>查看修改，语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git status -s # 查看有哪些文件发生了修改</div><div class="line">$ git diff # 查看具体修改</div><div class="line">$ git diff 文件名 # 查看对应文件的具体修改</div><div class="line">$ git diff 分支名 文件名 # 查看相对对应分支中的对应文件的具体修改</div></pre></td></tr></table></figure><ul><li>查看日志，语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git log</div><div class="line">$ git log -5 # 查看最近的 5 条日志</div><div class="line">$ git log -5 --graph # 以图的形式查看最近 5 条日志</div></pre></td></tr></table></figure><ul><li>代码回滚，语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git log # 查看一下日志</div><div class="line">$ git reset --hard 对应的标识值</div></pre></td></tr></table></figure><ul><li>还原指定文件，语法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout 文件名</div></pre></td></tr></table></figure><ul><li>拉取远程版本库更新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git fetch origin # 将远程仓库更新取回本地</div><div class="line">$ git pull origin # 将远程仓库更新取回本地并合并</div><div class="line">$ git pull origin master</div></pre></td></tr></table></figure><p>效果等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git fetch origin master</div><div class="line">$ git merge origin/master</div></pre></td></tr></table></figure><ul><li>git add 撤销</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset head</div></pre></td></tr></table></figure><p>工作中接触到的 90% 以上命令都在上面了。</p><p>高级进阶请移步<a href="https://git-scm.com/book/zh/v2" target="_blank">https://git-scm.com/book/zh/v2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文旨在于分分钟教你使用命令行进行 Git 配置与操作，废话不多说，直接上干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;git-安装&quot;&gt;&lt;a href=&quot;#git-安装&quot; class=&quot;headerlink&quot; title=&quot;git 安
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Git" scheme="https://yangl.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何指定某一IP走特定路由</title>
    <link href="https://yangl.me/2016/05/12/assign-ip-route/"/>
    <id>https://yangl.me/2016/05/12/assign-ip-route/</id>
    <published>2016-05-11T16:00:00.000Z</published>
    <updated>2017-09-21T08:38:39.616Z</updated>
    
    <content type="html"><![CDATA[<h4 id="路由添加"><a href="#路由添加" class="headerlink" title="路由添加"></a>路由添加</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route -p add [目标] [mask &lt;网络掩码&gt;] [网关] [metric &lt;度量值&gt;] [<span class="keyword">if</span> &lt;接口&gt;]。</div></pre></td></tr></table></figure><p>参数 描述</p><p><strong>目标</strong> 指定路由的网络目标。目标可以是 IP 地址或子网前缀(又称为网络地址或网络标识符)(其中前缀的主机位设为 0),<br>主机路由的 IP 地址或者 0.0.0.0(默认路由)。</p><p><strong>mask</strong> 指定与网络目标关联的子网掩码。子网掩码可以是IP地址或子网前缀的相应子网掩码、255.255.255.255<br>(主机路由)或者 0.0.0.0（默认路由）。如果省略了掩码，则将使用子网掩码255.255.255.255。由于定义路<br>由中目标和子网掩码之间的关系，目标不能比其对应的子网掩码更具特定性。换句话说,如果子网掩码中的位<br>为0，则目标中的对应位不能设为1。</p><p><strong>网关</strong> 指定前一跃点或下一跃点 IP</p><p><strong>地址</strong> 可通过此地址访问由网络目标和子网掩码定义的地址集。对于本地连接的子网路由，网关地址为分配给连接到子网的接口的 IP 址。对于远程路由（可通过一个或多个路由器使用），网关地址为分配给相邻路由器的可直接访问的 IP 地址。</p><p><strong>metric</strong> 指定路由的整数度量值(从1到9999),用于在路由表中的多个路由(这些路由最接近匹配要转发的数据包目标地址)间进行选择。将选择最低度量值的路由。度量值可以反映跃点数目、路径速度、路径可靠性、路径吞吐量或管理属性。</p><p><strong>if</strong> 指定访问目标所使用的接口的接口索引。有关接口及其对应的接口索引的列表，请使用路由打印命令的显示功能。可以对接口索引使用十进制或十六进制值。十六进制数以 0x 开头。省略 if 参数时，接口将通过网关地址确定。</p><h4 id="metric-度量值"><a href="#metric-度量值" class="headerlink" title="metric 度量值"></a>metric 度量值</h4><p>度量值也就是优先级 如果有多个到相同的目的地址条目 那度量值越低越优先<br>当然也可以用其它的办法来更改默认网关的值:</p><p>1.如ROUTE DELELTE 0.0.0.0，把2个默认网关都删掉，再新增。新增时注意设置METRIC这个值不能一样。</p><p>2.用ROUTE CHANGE 来变更两个默认网关的的外网网关的METRIC值。。</p><h4 id="改默认路由"><a href="#改默认路由" class="headerlink" title="改默认路由"></a>改默认路由</h4><p>route change 默认不能修改自动生成的路由，要修改自动生成路由，就要先加一条路由, 覆盖默认路由，<br>然后修改新增的路由即可</p><h4 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h4><p>指定访问45.32.35.45 走 192.168.10.2网关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route add -p 45.32.35.45 mask 255.255.255.255 192.168.10.2 metric 1</div></pre></td></tr></table></figure><h4 id="来看一下效果"><a href="#来看一下效果" class="headerlink" title="来看一下效果"></a>来看一下效果</h4><p><img src="/images/in-post/proute.png" alt="proute"><br><img src="/images/in-post/ping_route.png" alt="ping_route"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;路由添加&quot;&gt;&lt;a href=&quot;#路由添加&quot; class=&quot;headerlink&quot; title=&quot;路由添加&quot;&gt;&lt;/a&gt;路由添加&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="route" scheme="https://yangl.me/tags/route/"/>
    
      <category term="运维" scheme="https://yangl.me/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Sublime text 3 注册码</title>
    <link href="https://yangl.me/2016/05/04/Sublime%20text%203%20license%20key/"/>
    <id>https://yangl.me/2016/05/04/Sublime text 3 license key/</id>
    <published>2016-05-03T16:00:00.000Z</published>
    <updated>2017-09-21T08:37:41.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Sublime text 3 license key,these all tested available on 2016/05/04.<br>Feel free to enjoy them.</p></blockquote><p><img src="/images/in-post/sub_about.png" alt="sublime_about"><br><img src="/images/in-post/sub_license.png" alt="sub_license"></p><p>Sublime Text 3 build 3143 LICENSE</p><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–TwitterInc200 User LicenseEA7E-8900071D77F72E 390CDD93 4DCBA022 FAF6079061AA12C0 A37081C5 D0316412 4584D13694D7F7D4 95BC8C1C 527DA828 560BB037D1EDDD8C AE7B379F 50C9D69D B35179EF2FE898C4 8E4277A8 555CE714 E1FB0E43D5D52613 C3D12E98 BC49967F 7652EED29D2D2E61 67610860 6D338B72 5CF95C69E36B85CC 84991F19 7575D828 470A92AB—— END LICENSE ——</pre><p>Sublime Text 3 build 3103 LICENSE</p><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Nicolas HennionSingle User LicenseEA7E-8660758A01AA83 1D668D24 4484AEBC 3B04512C827B0DE5 69E9B07A A39ACCC0 F95F5410729D5639 4C37CECB B2522FB3 8D37FDC172899363 BBA441AC A5F47F08 6CD3B3FECEFB3783 B2E1BA96 71AAF7B4 AFB61B1D0CC513E7 52FF2333 9F726D2C CDE53B4A810C0D4F E1F419A3 CDA0832B 8440565A35BF00F6 4CA9F869 ED10E245 469C233E—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Anthony SansoneSingle User LicenseEA7E-87856328B9A648 42B99D8A F2E3E9E0 16DE076EE218B3DC F3606379 C33C1526 E8B58964B2CB3F63 BDF901BE D31424D2 082891B5F7058694 55FA46D8 EFC11878 0868F093B17CAFE7 63A78881 86B78E38 0F146238BAE22DBB D4EC71A1 0EC2E701 C7F9C6485CF29CA3 1CB14285 19A46991 E9A9867614FD4777 2D8A0AB6 A444EE0D CA009B54—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Alexey PlutalovSingle User LicenseEA7E-8607763DC19CC1 134CDF23 504DC871 2DE5CE55585DC8A6 253BB0D9 637C87A2 D8D0BA85AAE574AD BA7D6DA9 2B9773F2 324C5DEF17830A4E FBCF9D1D 182406E9 F883EA87E585BBA1 2538C270 E2E857C2 194283CA7234FF9E D0392F93 1D16E021 F191491763909E12 203C0169 3F08FFC8 86D06EA873DDAEF0 AC559F30 A6A67947 B60104C6—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Free Communities Consultoria em Informática LtdaSingle User LicenseEA7E-801302C154C122 4EFA4415 F1AAEBCC 315F3A7D2580735A 7955AA57 850ABD88 72A1DDD88D2CE060 CF980C29 890D74F2 53131895281E324E 98EA1FEF 7FF69A12 17CA7784490862AF 833E133D FD22141D D8C89B944C10A4D2 24693D70 AE37C18F 72EF0BE51ED60704 651BC71F 16CA1B77 496A0B19463EDFF9 6BEB1861 CA5BAD96 89D0118E—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Peter HallidaySingle User LicenseEA7E-8559883997BFF0 2856413A 7A555954 67069B7806D8CE12 63EAF079 AD039757 79E16D13C555AD90 465CBE53 10F6DFC4 D3A3C611411106F8 0CFEB15F 0A7BB891 111F5ED2C6AA8429 77913528 FA6291A9 B88D4550F1D6AB13 BF9153BC 91B4DFFE D296CFE0C1D8EB22 13D5F14E 75A699EC 49EDDC23D89D0F9B D240B10A A3712467 09DE7870—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Fred ZirdungSingle User LicenseEA7E-8446726089C0EC 22936E1A 1EADEBE2 B8654BBA5C98FFA6 C0FD1599 0364779B 071C74FBEEFE9EAB 92B3D867 CD1B32FE D190269F6FC08F8F 8D24191D 32828465 942CE58EAECE5307 08B62229 D788560A 6E0AAC4B48A2D9EE 24FD8CAA 07BEBDF2 28EA86D4CCB96084 6C34CAD2 E8A04F39 3B5A3CBC3B668BB7 C94D0B4B 847D6D7F 4BC07375—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–WixelSingle User LicenseEA7E-848235103D2969 8700C7ED 8173CF61 537000C0EB3C7ECB 5E750F17 6B42B67C A190090B7669164F C6F371A8 5A1D88D5 BDD0DA70C065892B 7CC1BB2B 1C8B8C7C F08E77897C2A5241 35F86328 4C8F70D9 C023D7C211245C36 59A730DB 72BDB9A7 D5B2030490E90E72 9F08CA25 73F49C20 179D938E5BC8BEDA 13457A69 39E6265F 233767F9—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Daniel RusselSingle User LicenseEA7E-9174209327EC62 44020C2A 45172A68 12FE13F11D22245B 680892EE F551F8EB C183D0328B4EDB4B 479CB7E4 07E42EDD A780021D56BADF42 AC05238B 023B47B1 EBA1B7DE6DF9A383 159F32AE 04EBE100 1278B1D252E81B60 C68AA2E8 F84A20BE FE7990EB5D44E4B6 16369263 1DDAACBC 280FF19E86CF4319 0B8615A8 4FF0512E B123B8EC—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Peter ErikssonSingle User LicenseEA7E-8900688E107C71 3100D6FC 2AC805BF 9E627C7772E710D7 43392469 D06A2F5B F9304FBDF5AB4DB2 7A95F172 FE68E300 42745819E94AB2DF C1893094 ECABADC8 71FEE76420224821 3EABF931 745AF882 87AD0A4B33C6E377 0210D712 CD2B1178 82601542C7FD8098 F45D2824 BC7DFB38 F1EBD38AD7A3AFE0 96F938EA 2D90BD72 9E34CDF0—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Ryan ClarkSingle User LicenseEA7E-8124792158A7DE B690A7A3 8EC04710 006A5EEB34E77CA3 9C82C81F 0DB6371B 79704E6F93F36655 B031503A 03257CCC 01B20F60D304FA8D B1B4F0AF 8A76C7BA 0FA94D5556D46BCE 5237A341 CD837F30 4D60772D349B1179 A996F826 90CDB73C 24D41245FD032C30 AD5E7241 4EAA66ED 167D91FB55896B16 EA125C81 F550AF6B A6820916—— END LICENSE ——</pre><pre style="border:none;margin-bottom:20px;">—– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE ——</pre><p><a href="http://www.sublimetext.com/3" target="_blank">Sublime text 3 官网下载</a>  </p><p>青年节快乐, 愉快的去玩耍吧 :)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Sublime text 3 license key,these all tested available on 2016/05/04.&lt;br&gt;Feel free to enjoy them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Sublime Text 3" scheme="https://yangl.me/tags/Sublime-Text-3/"/>
    
      <category term="前端工具" scheme="https://yangl.me/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的前世今生</title>
    <link href="https://yangl.me/2015/09/22/js-version/"/>
    <id>https://yangl.me/2015/09/22/js-version/</id>
    <published>2015-09-21T16:00:00.000Z</published>
    <updated>2017-09-21T08:38:23.256Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 有着很奇怪的命名史。</p><p>1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript <em>（当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系）</em></p><p><img src="/images/in-post/post-js-version/javascript-java.jpg" alt="java-javascript"><br><small class="img-hint">歪果仁的笑话怎么一点都不好笑</small></p><blockquote><p>译者注：<a href="https://en.wikipedia.org/wiki/JavaScript#History" target="_blank" rel="external">wikipedia 的 JavaScript 词条</a> 更详细的叙述了这段历史</p></blockquote><p>1996 年，网景将 JavaScript 提交给 <a href="http://www.ecma-international.org/" target="_blank" rel="external">ECMA International（欧洲计算机制造商协会）</a> 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。</p><blockquote><p>术语（译者注）：</p><ul><li><em>标准（Standard）</em>： 用于定义与其他事物区别的一套规则</li><li><em>实现（Implementation）</em>： 某个标准的具体实施/真实实践</li></ul></blockquote><p>不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。</p><blockquote><p>译者注：<a href="https://en.wikipedia.org/wiki/ECMAScript#4th_Edition_.28abandoned.29" target="_blank" rel="external">ECMAScript 第四版草案</a>由于太过激进而被抛弃，Adobe 的 <a href="https://en.wikipedia.org/wiki/ActionScript" target="_blank" rel="external">ActionScript 3.0</a> 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了）</p></blockquote><p>到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015）</p><p>目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 <a href="https://github.com/wycats/javascript-decorators" target="_blank" rel="external">decorators（装饰者）</a>，<a href="https://github.com/lukehoban/ecmascript-asyncawait" target="_blank" rel="external">async-await（async-await 异步编程模型）</a> 和 <a href="https://github.com/jeffmo/es-class-properties" target="_blank" rel="external">static class properties（静态类属性）</a>。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 <a href="https://babeljs.io/docs/usage/experimental/" target="_blank" rel="external">Babel 的官网</a> 上查看各个提案目前都在哪个阶段了。</p><p>所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你：</p><ul><li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li><li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li><li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li><li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li><li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li><li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li></ul><p>在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。</p><h4 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h4><ul><li>TC39 的 <a href="https://github.com/tc39/ecma262" target="_blank" rel="external">Github 仓库</a>上可以看到所有目前公开的提案</li><li>如果你还不熟悉 ES6，Babel 有一个<a href="https://babeljs.io/docs/learn-es2015/" target="_blank" rel="external">很不错的特性概览</a></li><li>如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 <a href="http://exploringjs.com/" target="_blank" rel="external">Exploring ES6</a>和 Nicholas Zakas 的 <a href="https://leanpub.com/understandinges6" target="_blank" rel="external">Understanding ECMAScript 6</a>。Axel 的博客 <a href="http://www.2ality.com/" target="_blank" rel="external">2ality</a> 也是很不错的 ES6 资源</li></ul><p><img class="shadow" width="320" src="/images/in-post/post-js-version/keep-calm-and-learn-javascript.png"><br><small class="img-hint">来学 JavaScript 吧！</small></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript 有着很奇怪的命名史。&lt;/p&gt;
&lt;p&gt;1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScrip
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="前端开发" scheme="https://yangl.me/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://yangl.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈JavaScript的模块化</title>
    <link href="https://yangl.me/2015/05/25/js-module-loader/"/>
    <id>https://yangl.me/2015/05/25/js-module-loader/</id>
    <published>2015-05-24T16:00:00.000Z</published>
    <updated>2017-09-21T08:38:07.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Foreword"><a href="#Foreword" class="headerlink" title="Foreword"></a>Foreword</h2><blockquote><p>Here comes Module!</p></blockquote><p>随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。</p><p>于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。</p><hr><h2 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h2><ol><li><a href="#commonjs--node">CommonJS &amp; Node</a></li><li><a href="#history">History</a></li><li><a href="#requirejs--amd">RequireJS &amp; AMD</a></li><li><a href="#seajs--cmd">SeaJS &amp; CMD</a></li><li><a href="#amd-vs-cmd">AMD vs CMD</a></li><li><a href="#webpack">WebPack</a></li></ol><h2 id="CommonJS-amp-Node"><a href="#CommonJS-amp-Node" class="headerlink" title="CommonJS &amp; Node"></a>CommonJS &amp; Node</h2><blockquote><p>Javascript: not just for browsers any more! —— CommonJS Slogen</p></blockquote><p>前端模块化的事实标准之一，2009 年 8 月，<a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank" rel="external">CommonJS</a> 诞生。</p><p>CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。</p><p>让我们看看 Node 中的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper</span></div><div class="line"><span class="comment">// "as though the module was wrapped in a function"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)  <span class="comment">// 加载模块（同步加载）</span></div><div class="line">a.doSomething()         <span class="comment">// 等上一句执行完才会执行</span></div><div class="line"></div><div class="line">exports.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 暴露 b 函数接口</span></div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>exports</code>是一个内置对象，就像<code>require</code>是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写<code>module.exports</code>就可以了。</p><p>CommonJS 前身叫 ServerJS ，<strong>后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS</strong> 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。</p><p>因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是：</p><ul><li>采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境）</li><li>虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。</li><li>都在向着 <strong>COMMON</strong> 的方向进化：<strong>兼容不同风格，兼容浏览器和服务器两种环境</strong></li></ul><p>本文接下来要讨论的典例是：</p><ul><li>RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法）</li><li>SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法）</li></ul><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><!--<h2 id="history"> History </h2>--><blockquote><p>此段落参考自玉伯的 <a href="https://github.com/seajs/seajs/issues/588" target="_blank" rel="external">前端模块化开发那点历史</a></p></blockquote><p>09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 <a href="http://wiki.commonjs.org/wiki/Modules" target="_blank" rel="external">Modules/1.0</a> 规范，并且在 Node.js 等环境下取得了很不错的实践。</p><p>09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：</p><ol><li><strong>Modules/1.x</strong> 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 <a href="http://wiki.commonjs.org/wiki/Modules/Transport" target="_blank" rel="external">Modules/Transport</a> 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。</li><li><strong>Modules/Async</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 <a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" target="_blank" rel="external">AMD</a> 规范及其实现 <a href="http://requirejs.org/" target="_blank" rel="external">RequireJS</a>。这个稍后再细说。</li><li><strong>Modules/2.0</strong> 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了</li></ol><p>补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 <code>add</code>和<code>use</code> 两个源自于 YUI Modules 的函数名替换了 <code>define</code> 和 <code>require</code> ，但其原理更接近 RequireJS ，与 YUI Modules 的 <code>Y</code> 沙箱 Attach 机制并不相同</p><h2 id="RequireJS-amp-AMD"><a href="#RequireJS-amp-AMD" class="headerlink" title="RequireJS &amp; AMD"></a>RequireJS &amp; AMD</h2><p><a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition" target="_blank" rel="external">AMD (Async Module Definition)</a> 是 RequireJS 在推广过程中对模块定义的规范化产出。</p><blockquote><p>RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments</p></blockquote><p>RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//CommonJS</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> Employee = <span class="built_in">require</span>(<span class="string">"types/Employee"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Programmer</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">&#125;  </div><div class="line"></div><div class="line">Programmer.prototype = <span class="keyword">new</span> Employee();</div><div class="line"></div><div class="line"><span class="comment">//如果 require call 是异步的，那么肯定 error</span></div><div class="line"><span class="comment">//因为在执行这句前 Employee 模块肯定来不及加载进来</span></div></pre></td></tr></table></figure><blockquote><p>As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do?</p></blockquote><p>所以我们需要 <strong>Function Wrapping</strong> 来获取依赖并且提前通过 script tag 提前加载进来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//AMD Wrapper</span></div><div class="line"></div><div class="line">define(</div><div class="line">    [types/Employee],    <span class="comment">//依赖</span></div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">Employee</span>)</span>&#123;  <span class="comment">//这个回调会在所有依赖都被加载后才执行</span></div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Programmer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="comment">//do something</span></div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Programmer.prototype = <span class="keyword">new</span> Employee();</div><div class="line">        <span class="keyword">return</span> Programmer;  <span class="comment">//return Constructor</span></div><div class="line">    &#125;</div><div class="line">)</div></pre></td></tr></table></figure><p>当依赖模块非常多时，这种<strong>依赖前置</strong>的写法会显得有点奇怪，所以 AMD 给了一个语法糖， <strong>simplified CommonJS wrapping</strong>，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dependency1 = <span class="built_in">require</span>(<span class="string">'dependency1'</span>),</div><div class="line">        dependency2 = <span class="built_in">require</span>(<span class="string">'dependency2'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>The AMD loader will parse out the <code>require(&#39;&#39;)</code> calls by using <code>Function.prototype.toString()</code>, then internally convert the above define call into this:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'require'</span>, <span class="string">'dependency1'</span>, <span class="string">'dependency2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dependency1 = <span class="built_in">require</span>(<span class="string">'dependency1'</span>),</div><div class="line">        dependency2 = <span class="built_in">require</span>(<span class="string">'dependency2'</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>出于<code>Function.prototype.toString()</code>兼容性和性能的考虑，最好的做法还是做一次 <strong>optimized build</strong></p><p>AMD 和 CommonJS 的核心争议如下：</p><h3 id="1-执行时机"><a href="#1-执行时机" class="headerlink" title="1. 执行时机"></a>1. <strong>执行时机</strong></h3><p>Modules/1.0:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>) <span class="comment">// 执行到此时，a.js 才同步下载并执行</span></div></pre></td></tr></table></figure><p>AMD: （使用 require 的语法糖时）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">"require"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">require</span>))</span>&#123;</div><div class="line">    <span class="comment">// 在这里，a.js 已经下载并且执行好了</span></div><div class="line">    <span class="comment">// 使用 require() 并不是 AMD 的推荐写法</span></div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">"./a"</span>) <span class="comment">// 此处仅仅是取模块 a 的 exports</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的）</p><p>但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。</p><h3 id="2-书写风格"><a href="#2-书写风格" class="headerlink" title="2. 书写风格"></a>2. <strong>书写风格</strong></h3><p>AMD 推荐的风格并不使用<code>require</code>，而是通过参数传入，破坏了<strong>依赖就近</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>)</span>&#123;</div><div class="line">    <span class="comment">// 提前申明了并初始化了所有模块</span></div><div class="line"></div><div class="line">    <span class="literal">true</span> || b.foo(); <span class="comment">//即便根本没用到模块 b，但 b 还是提前执行了。</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>不过，在笔者看来，风格喜好因人而异，主要还是<strong>预执行</strong>和<strong>懒执行</strong>的差异。</p><p>另外，require 2.0 也开始思考异步处理<strong>软依赖</strong>（区别于一定需要的<strong>硬依赖</strong>）的问题，提出了这样的方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数体内：</span></div><div class="line"><span class="keyword">if</span>(status)&#123;</div><div class="line">    <span class="keyword">async</span>([<span class="string">'a'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">        a.doSomething()</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="SeaJS-amp-CMD"><a href="#SeaJS-amp-CMD" class="headerlink" title="SeaJS &amp; CMD"></a>SeaJS &amp; CMD</h2><p>CMD (Common Module Definition) 是 <a href="http://seajs.org/docs/" target="_blank" rel="external">SeaJS</a> 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。</p><p>不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。</p><ul><li>CMD Specification<ul><li><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank" rel="external">English (CMDJS-repo)</a></li><li><a href="https://github.com/seajs/seajs/issues/242" target="_blank" rel="external">Chinese (SeaJS-repo)</a></li></ul></li></ul><p>CMD 主要有 define, factory, require, export 这么几个东西</p><ul><li>define <code>define(id?, deps?, factory)</code></li><li>factory <code>factory(require, exports, module)</code></li><li>require <code>require(id)</code></li><li>exports <code>Object</code></li></ul><p>CMD 推荐的 Code Style 是使用 CommonJS 风格的 <code>require</code>：</p><ul><li>这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 获取模块 a 的接口</span></div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</div><div class="line">    <span class="comment">// 调用模块 a 的方法</span></div><div class="line">    a.doSomething();</div><div class="line"></div><div class="line">    <span class="comment">// 对外提供 foo 属性</span></div><div class="line">    exports.foo = <span class="string">'bar'</span>;</div><div class="line">    <span class="comment">// 对外提供 doSomething 方法</span></div><div class="line">    exports.doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">'hello'</span>, [<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 模块代码...</span></div><div class="line"></div><div class="line">    <span class="comment">// 直接通过 return 暴露接口</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        foo: <span class="string">'bar'</span>,</div><div class="line">        doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。</p><h2 id="AMD-vs-CMD"><a href="#AMD-vs-CMD" class="headerlink" title="AMD vs CMD"></a>AMD vs CMD</h2><p><strong>虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同：</strong></p><ol><li>对于依赖的模块，AMD 是<strong>提前执行</strong>，CMD 是<strong>懒执行</strong>。（都是先加载）</li></ol><ul><li>CMD 推崇<strong>依赖就近</strong>，AMD 推崇<strong>依赖前置</strong>。   </li></ul><p>看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// AMD 默认推荐</span></div><div class="line"></div><div class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;  <span class="comment">// 依赖前置，提前执行</span></div><div class="line"></div><div class="line">    a.doSomething()</div><div class="line">    b.doSomething()</div><div class="line"></div><div class="line">&#125;)</div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CMD</span></div><div class="line"></div><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</div><div class="line">    a.doSomething()</div><div class="line"></div><div class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖就近，延迟执行</span></div><div class="line">    b.doSomething()</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="WebPack"><a href="#WebPack" class="headerlink" title="WebPack"></a>WebPack</h2><blockquote><p>working…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Foreword&quot;&gt;&lt;a href=&quot;#Foreword&quot; class=&quot;headerlink&quot; title=&quot;Foreword&quot;&gt;&lt;/a&gt;Foreword&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Here comes Module!&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="前端开发" scheme="https://yangl.me/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
      <category term="JavaScript" scheme="https://yangl.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Unix&amp;Linux</title>
    <link href="https://yangl.me/2015/04/14/unix-linux-note/"/>
    <id>https://yangl.me/2015/04/14/unix-linux-note/</id>
    <published>2015-04-13T16:00:00.000Z</published>
    <updated>2017-09-21T08:37:52.345Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>This document is not completed and will be updated anytime.</p></blockquote><h2 id="Catagory"><a href="#Catagory" class="headerlink" title="Catagory"></a>Catagory</h2><ol><li><a href="#unix">Unix</a><ol><li><a href="#bell-labs">Bell Labs</a></li><li><a href="#xenix">Xenix</a></li><li><a href="#bsd">BSD</a></li><li><a href="#freebsd--apple">FreeBSD &amp; Apple</a></li><li><a href="#nextstep">NeXTStep</a></li><li><a href="#darwin">Darwin</a></li><li><a href="#posix">POSIX</a></li></ol></li><li><a href="#unix-like">Unix-like</a><ol><li><a href="#single-unix-specification">Single Unix Specification</a></li><li><a href="#apple-ios">Apple iOS</a></li><li><a href="#xnu-kernel">XNU Kernel</a></li></ol></li><li><a href="#linux">Linux</a><ol><li><a href="#linux-kernel">Linux Kernel</a></li><li><a href="#gnu-project">GNU Project</a></li><li><a href="#android">Android</a></li><li><a href="#android-kernel">Android Kernel</a></li><li><a href="#android-rom">Android ROM</a></li><li><a href="#chrome-os">Chrome OS</a></li><li><a href="#chromium-os">Chromium OS</a></li></ol></li></ol><hr><h2 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h2><blockquote><p>Unix is a <strong>family</strong> of multitasking, multiuser computer OS.</p></blockquote><p>Derive from the original <strong>AT&amp;T Unix</strong>, Developed in the 1970s at <strong>Bell Labs</strong> (贝尔实验室), initially intended for use inside the <strong>Bell System</strong>.</p><ul><li><h4 id="Bell-Labs"><a href="#Bell-Labs" class="headerlink" title="Bell Labs"></a>Bell Labs</h4>Bell 和 AT&amp;A 在那时已经是一家了，可以看到那时的通信公司真是一线 IT 公司呢。<br><strong>C 语言也是 Bell Labs 的产物</strong>，从一开始就是为了用于 Unix 而设计出来的。所以 Unix （在 73 年用 C 重写）在高校流行后，C 语言也获得了广泛支持。</li></ul><p>AT&amp;T licensed Unix to outside parties(第三方) from the late 1970s, leading to a variety of both <strong>academic</strong> (最有有名的 BSD ) and <strong>commercial</strong> (Microsoft Xenix, IBM AIX, SunOS Solaris)</p><ul><li><h4 id="Xenix"><a href="#Xenix" class="headerlink" title="Xenix"></a>Xenix</h4><p>微软 1979 年从 AT&amp;A 授权来的 Unix OS，配合着 x86 成为当时最受欢迎的 Unix 发行版。后来 M$ 和 IBM 合作开发 OS/2 操作系统后放弃，后来最终转向 <strong>Windows NT</strong>。</p></li><li><h4 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h4><p><strong>Barkeley Software Distribution</strong>, also called Berkeley Unix. Today the term “BSD” is used to refer to any of the BSD descendants(后代) which together form a branch of the family of Unix-like OS.(共同组成了一个分支)</p><ul><li><strong>BSD 最大的贡献是在 BSD 中率先增加了虚拟存储器和 Internet 协议</strong>，其 TCP/IP(IPv4 only) 代码仍然在现代 OS 上使用（ Microsoft Windows and most of the foundation of Apple’s OS X and iOS ）</li><li>BSD 后来发展出了众多开源后代，包括 FreeBSD, OpenBSD, NetBSD 等等……很多闭源的 vendor Unix 也都从 BSD 衍生而来。</li></ul></li><li><h4 id="FreeBSD-amp-Apple"><a href="#FreeBSD-amp-Apple" class="headerlink" title="FreeBSD &amp; Apple"></a>FreeBSD &amp; Apple</h4><p>FreeBSD 不但是 Open Source BSD 中占有率最高的，还直接影响了 Apple Inc : NeXT Computer 的团队在 FreeBSD 上衍生出了 NeXTSTEP 操作系统，这货后来在 Apple 时期演化成了 <strong>Darwin</strong> ，这个“达尔文”居然还是个开源系统，而且是 the Core of <strong>Mac OS X</strong> and <strong>iOS</strong>.</p></li><li><h4 id="NeXTSTEP"><a href="#NeXTSTEP" class="headerlink" title="NeXTSTEP"></a>NeXTSTEP</h4><p>An <strong>object-oriented</strong>, multitasking OS. Low-level C but High-level OC language and runtime the first time, combined with an <strong>OO aplication layer</strong> and including several “kits”.<br>大家都知道 NeXT 是 Steve Jobs 被 forced out of Apple 后和 a few of his coworkers 创办的，所以 <strong>NeXTSTEP 绝对是证明 Jobs 实力的作品。</strong></p></li><li><h4 id="Darwin"><a href="#Darwin" class="headerlink" title="Darwin"></a>Darwin</h4><p><a href="http://en.wikipedia.org/wiki/Darwin_(operating_system\" target="_blank" rel="external">Darwin</a>), the core set of components upon which Mac OS X and iOS based, mostly POSIX compatible, but has never, by itself, been certified as being compatible with any version of <strong>POSIX</strong>. (OS X, since Leopard, has been certified as compatible with the Single UNIX Specification version 3)<br><strong>所以说 Mac OS X 算是很正统 Unix 的了</strong></p></li><li><h4 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h4><p>可移植操作系统接口, Portable Operating System Interface, is a family of standards specified by the IEEE from maintaining compatibility between OS, defines the API along with Command Line Shells and utility interfaces, for software comaptibility with variants of Unix and other OS.</p><ul><li>Fully POSIX compliant:<ul><li>OS X</li><li>QNX OS (BlackBerry)</li></ul></li><li>Mostly complicant:<ul><li>Linux</li><li>OpenBSD/FreeBSD</li><li>Darwin (Core of <strong>iOS</strong> &amp; OS X)</li><li><strong>Android</strong></li></ul></li><li>Complicant via compatibility feature （通过兼容功能实现兼容）<ul><li>Windows NT Kernel<ul><li>Windows Server 2000, 2003, 2008, 2008 R2, 2012</li></ul></li><li>Symbian OS (with PIPS)<ul><li>Symbian was a closed-source OS.</li></ul></li></ul></li></ul></li></ul><hr><h2 id="Unix-like"><a href="#Unix-like" class="headerlink" title="Unix-like"></a>Unix-like</h2><blockquote><p>A Unix-like (sometimes referred to as UN<em>X or </em>nix) operating system is one that behaves in a manner similar to a Unix system, while not necessarily conforming to or being certified to any version of the <strong>Single UNIX Specification</strong>.</p></blockquote><p>There is no standard for defining the term.<br>其实 Unix-like 是个相对模糊的概念：</p><ul><li>最狭义的 Unix 单指 Bell Labs’s Unix</li><li>稍广义的 Unix 指代所有 Licensed Unix, 即通过了 SUS 的 Unix-like ，比如 OS X</li><li>最广义的 Unix 即所有 Unix-like 系统，无论它是否通过过任何 SUS，包括 Linux，BSD Family 等</li></ul><h4 id="Single-UNIX-Specification"><a href="#Single-UNIX-Specification" class="headerlink" title="Single UNIX Specification"></a>Single UNIX Specification</h4><p>The Single UNIX Specification (SUS) is the collective name of a family of standards for computer OS, compliance with which is required to <strong>qualify for the name “Unix”</strong>, like <strong>POSIX</strong>.</p><h4 id="Apple-iOS"><a href="#Apple-iOS" class="headerlink" title="Apple iOS"></a>Apple iOS</h4><p>iOS is a <strong>Unix-like OS based on Darwin(BSD)</strong> and OS X, which share some frameworks including Core Foundation, Founadtion and the Darwin foundation with OS X, but, Unix-like shell access is not avaliable for users and restricted for apps, <strong>making iOS not fully Unix-compatible either.</strong></p><p>The iOS kernal is <strong>XNU</strong>, the kernal of Darwin.</p><h4 id="XNU-Kernel"><a href="#XNU-Kernel" class="headerlink" title="XNU Kernel"></a>XNU Kernel</h4><p>XNU, the acronym(首字母缩写) for <strong><em>X is Not Unix</em></strong>, which is the <strong>Computer OS Kernel</strong> developed at Apple Inc since Dec 1996 for use in the Mac OS X and released as free open source software as part of Darwin.</p><hr><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><blockquote><p>Linux is a Unix-like and mostly POSIX-compliant computer OS.</p></blockquote><p><img src="/images/in-post/800px-Unix_timeline.en.svg.png" alt="Unix_timeline"></p><h4 id="Linux-Kernel"><a href="#Linux-Kernel" class="headerlink" title="Linux Kernel"></a>Linux Kernel</h4><p>严格来讲，术语 Linux 只表示 <a href="http://en.wikipedia.org/wiki/Linux_kernel" target="_blank" rel="external">Linux Kernel</a> 操作系统内核本身，比如说 Android is Based on Linux (Kernel). Linus 编写的也只是这一部分，一个免费的 Unix-like Kernel，并不属于 GNU Project 的一部分。</p><p>但通常把 Linux 作为 Linux Kernel 与大量配合使用的 GNU Project Software Kit (包括 Bash, Lib, Compiler, 以及后期的 GUI etc) 所组合成的 OS 的统称。（包括各类 Distribution 发行版）</p><p>这类操作系统也被称为 <strong>GNU/Linux</strong></p><h4 id="GNU-Project"><a href="#GNU-Project" class="headerlink" title="GNU Project"></a>GNU Project</h4><p>The GNU Project is a <strong>free software, mass collaboration</strong> project, which based on the following freedom rights:</p><ul><li>Users are free to run the software, share (copy, distribute), study and modify it.</li><li>GNU software guarantees these freedom-rights legally (via its license).</li><li>So it is not only FREE but, more important, FREEDOM.</li></ul><p>In order to ensure that the <em>entire</em> software of a computer grants its users all freedom rights (use, share, study, modify), even the most fundamental and important part, <strong>the operating system</strong>, needed to be written.</p><p>This OS is decided to called <strong>GNU (a recursive acronym meaning “GNU is not Unix”)</strong>. By 1992, the GNU Project had completed all of the major OS components except for their kernel, <em>GNU Hurd</em>.</p><p>With the release of the third-party <strong>Linux Kernel</strong>, started independently by <em>Linus Torvalds</em> in 1991 and released under the GPLv0.12 in 1992, for the first time it was possible to run an OS <strong>composed completely of free software</strong>.</p><p>Though the Linux kernel is not part of the GNU project, it was developed using GCC and other GNU programming tools and was released as free software under the GPL.</p><p>Anyway, there eventually comes to the <strong>GNU/Linux</strong></p><ul><li><strong>GPL</strong>: GNU General Public License</li><li><strong>GCC</strong>: GNU Compiler Collection</li></ul><p>其他与 GPL 相关的自由/开源软件公共许可证：</p><ul><li><a href="http://en.wikipedia.org/wiki/Mozilla_Public_License" target="_blank" rel="external">Mozilla Public License</a></li><li><a href="http://en.wikipedia.org/wiki/MIT_License" target="_blank" rel="external">MIT License</a></li><li><a href="http://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="external">BSD Public License</a><ul><li>GPL 强制后续版本必须是自由软件，而 BSD 的后续可以选择继续开源或者封闭</li></ul></li><li><a href="http://en.wikipedia.org/wiki/Apache_License" target="_blank" rel="external">Apache License</a></li></ul><p><img src="/images/in-post/public-license.png" alt="Public License"></p><h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>Android is a mobile OS based on <strong>Linux Kernel</strong>, so it’s definitely <strong>Unix-like</strong>.  </p><p><strong>Linux is under GPL so Android has to be open source</strong>.<br>Android’s source code is released by Google under open source licenses, although most Android devices ultimately ship with a combination of open source and proprietary software, including proprietary software developed and licensed by Google <em>(GMS are all proprietary)</em>  </p><h4 id="Android-Kernel"><a href="#Android-Kernel" class="headerlink" title="Android Kernel"></a>Android Kernel</h4><p>Android’s kernel is based on one of the Linux kernel’s long-term support (LTS) branches.   </p><p><strong>Android’s variant of the Linux kernel</strong> has further architectural changes that are implemented by Google outside the typical Linux kernel development cycle, and, certain features that Google contributed back to the Linux kernel. Google maintains a public code repo that contains their experimental work to re-base Android off the latest stable Linux versions.</p><p>Android Kernel 大概是 Linux Kernel 最得意的分支了，Android 也是 Linux 最流行的发行版。不过，也有一些 Google 工程师认为 Android is not Linux in the traditional Unix-like Linux distribution sense. 总之这类东西就算有各种协议也还是很难说清楚，在我理解里 Android Kernel 大概就是 fork Linux Kernel 之后改动和定制比较深的例子。</p><h4 id="Android-ROM"><a href="#Android-ROM" class="headerlink" title="Android ROM"></a>Android ROM</h4><p>既然提到 Android 就不得不提提 Android ROM</p><p>ROM 的本义实际上是只读内存：  </p><p><strong>Read-only memory</strong> (ROM) is a class of storage medium used in computers and other electronic devices. Data stored in ROM can only be modified slowly, with difficulty, or not at all, so it is <strong>mainly used to distribute firmware (固件)</strong> (software that is very closely tied to specific hardware, and unlikely to need frequent updates).</p><p>ROM 在发展的过程中不断进化，从只读演变成了可编程可擦除，并最终演化成了 Flash  </p><ul><li>PROM (Programmable read-only memory)</li><li>EPROM (Erasable programmable read-only memory)</li><li>EEPROM (Electrically erasable programmable read-only memory)<ul><li>Flash memory (闪存)</li></ul></li></ul><p>Flash 的出现是历史性的，它不但可以作为 ROM 使用，又因其极高的读写速度和稳定性，先后发展成为U盘（USB flash drives）、移动设备主要内置存储，和虐机械硬盘几条街的固态硬盘（SSD），可以说这货基本统一了高端存储市场的技术规格。</p><p>所以我们平时习惯说的 ROM 其实还是来源于老单片机时代，那时的 ROM 真的是写了就很难（需要上电复位）、甚至无法修改，所以那时往 ROM 里烧下去的程序就被称作 firmware ，固件。久而久之，虽然技术发展了，固件仍然指代那些不常需要更新的软件，而 ROM 这个词也就这么沿用下来了。</p><p>所以在 wiki 里是没有 Android ROM 这个词条的，只有 <a href="http://en.wikipedia.org/wiki/List_of_custom_Android_firmwares" target="_blank" rel="external">List of custom Android firmwares</a></p><blockquote><p>A custom firmware, also known as a custom ROM, ROM, or custom OS, is an aftermarket distribution of the Android operating system. They are based on the Android Open Source Project (AOSP), hence most are open-sourced releases, unlike proprietary modifications by device manufacturers.</p></blockquote><p>各类 Android ROM 在 Android 词类下也都是属于 <strong>Forks and distributions</strong> 一类的。</p><p>所以我说，其实各类 Android ROM 也好，fork Android 之流的 YunOS、FireOS 也好，改了多少东西，碰到多深的 codebase ……<strong>其实 ROM 和 Distribution OS 的界限是很模糊的</strong>，为什么 Android 就不可以是移动时代的 Linux ，为什么 Devlik/ART 就不能是移动时代的 GCC 呢？</p><h4 id="Chrome-OS"><a href="#Chrome-OS" class="headerlink" title="Chrome OS"></a>Chrome OS</h4><p>Chrome OS is an operating system based on the <strong>Linux kernel</strong> and designed by Google to work with web applications and installed applications.</p><p>虽然目前只是个 Web Thin Client OS ，但是 RoadMap 非常酷……</p><ul><li><strong>Chrome Packaged Application</strong> (Support working offline and installed)</li><li><strong>Android App Runtime</strong> (run Android applications natively…fxxking awesome)</li></ul><p>平复一下激动的心情，还是回到正题来：</p><h4 id="Chromium-OS"><a href="#Chromium-OS" class="headerlink" title="Chromium OS"></a>Chromium OS</h4><p>Chrome OS is based on Chromium OS, which is the open-source development version of Chrome OS, which is a <strong>Linux distribution</strong> designed by Google.</p><p>For Detail, Chromium OS based on <a href="http://en.wikipedia.org/wiki/Gentoo_Linux" target="_blank" rel="external">Gentoo Linux</a>, emm…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;This document is not completed and will be updated anytime.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Catagory&quot;&gt;&lt;a href=&quot;#Catagory&quot; class=&quot;h
      
    
    </summary>
    
      <category term="技术博客" scheme="https://yangl.me/categories/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="OS" scheme="https://yangl.me/tags/OS/"/>
    
      <category term="Unix" scheme="https://yangl.me/tags/Unix/"/>
    
      <category term="Linux" scheme="https://yangl.me/tags/Linux/"/>
    
  </entry>
  
</feed>
